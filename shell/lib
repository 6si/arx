#!/bin/sh

# Note that shell variables are implicitly global. Thus, we require that all
# variables used in a function must be set in that function. Idempotent
# generators, like `tag', allow variables to be shared.

screen_S() {
  tag="`tag`"
  screen -S "$tag" "$@"
}

# Initialize screen with settings. Settings are fed to screen's eval function,
# so each argument should be a string containg a whole setting, for example:
#
#   screen_setup 'zombie ko' 'defutf8 on'
#
screen_setup() {
  if [ ! -n "${screen_setup:-}" ]
  then
    tag="`tag`"
    ! { screen -ls | fgrep -q "$tag" ;} ||
      { echo 'ERR: screen collision!' 1>&2 ; return 2 ;}
    ( cd / ; screen_S -dm -ln sleep 2 ) # Ensure PWD for screen is /.
    screen_setup=true
    screen_S      -X eval 'screen 1 sleep 1' 'select 0' kill "$@"
  fi
}

# Launch command in initialized screen.
screend() {
  tag="`tag`"
  screen_setup
  screen_S      -X screen 0 "$@"
  screen_S      -X eval 'select 1' kill
  echo "$tag"
}


# Log to files o and e in the present directory.
files_oe() {
  "$@" 2>e 1>o
}

tee_oe() {
  general_redirect o e tee "$@"
}

syslog_oe() {
  general_redirect user.err user.info logger_shim "$@"
}

logger_shim() {
  tag="`tag`"
  logger -t "$tag" -i -p "$1"
}

# This redirect pattern is used for tee and logger.
general_redirect() {
  o="$1" ; e="$2" ; c="$3"
  shift  ; shift  ; shift
{   exec      3>&1 # Here, &1 refers to the grouping's STDOUT. We save it in &3.
  # In this line, &1 and &2 refer to the file descriptors of the command, not
  # of the grouping. We cause the STDERR reference to point to the new output
  # stream for this command, which is a pipe to the error logger, while we
  # cause the STDOUT reference to point to the output stream of the grouping
  # as a whole, which is a piped to the output logger.
    "$@"      2>&1 1>&3 |
  # Cause whatever output is produced by the error logger to go back on
  # STDERR. Tee will copy its input to STDOUT and logger can be made to copy
  # its input to STDERR; we handle both cases.
    "$c" "$e" 2>&2 1>&2
  # Cause whatever output is produced by the output logger to go back on
  # STDOUT, similar to the case for the error logger.
} | "$c" "$o" 2>&1 1>&1
}


# Generates a tag for this process from the label, the date up to seconds and
# the PID. The tag is used to label screen sessions, temporary directories and
# so forth. It is very unlikely the tag will collide with any other created
# tag; but all commands that create resources, like screen_setup, should check
# for a collision and fail if one is found.
tag() {
  if [ ! -n "${tag:-}" ]
  then
    : ${label:=arx} # Templated.
    tag="$label".`date -u +%FT%TZ`.$$
  fi
  echo "$tag"
}


# Have to wrap cd so we can change the directory within the context of
# external calls to the script. For example,
#
#  ./lib cd_ <dir> files_oe
#
cd_() {
  cd "$1"
  shift
  "$@"
}

"$@"

