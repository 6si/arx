#!/bin/sh
# Note that some functions have "signatures" given with #### comments. Be sure
# to update the signatures when their dependencies on global variables change.

main() {
  set -eu
  vars defaults "$@"
}

# Sets defualts for unset vars and calls "$@".
defaults() {
  : ${rm0:=true}
  : ${rm1:=true}
  : ${tmp:=/tmp}
  : ${flat_token:=true}
  : ${prefix:=arx}
  : ${token:=`time_and_pid "$flat_token"`}
  : ${tag:=${prefix:+${prefix}_}$token}
  : ${screen:=$tag}
  : ${dir:=$tmp/$tag}
  : ${work_dir:=$dir/cwd}
  : ${syslog_tag:=$tag}
  pwd="`pwd -P`"
  "$@"
}

# Use recursion to process arguments for name=value pairs and set local shell
# variables in accord with them. When we're done with name=value pairs, call
# $1 with the remaining arguments.
vars() {
  command="$1" ; shift
  case "${1:-}" in
    command=*) err 'vars: It is an error to set command=...' ;;
    *=*)       typeset "$1" ; shift ; vars "$command" "$@" ;;
    *)         "$command" "$@"
  esac
}

# Generates an ID that is very likely unique on this system -- date to seconds
# and PID -- and optionally strips characters that make it easier to read but
# harder to use in URLs, in git branches, with Hadoop, in some build systems,
# in the PATH and probably many other things.
time_and_pid() {
  date -u +%FT%TZ#$$ | { ! $1 && cat || { tr -d :- | tr '#' _ ;} ;}
}


#### main screen=... screen_S
screen_S() {
  screen -S "$screen" "$@"
}

# Initialize screen with settings. Settings are fed to screen's eval function,
# so each argument should be a string containg a whole setting, for example:
#
#   screen_setup 'zombie ko' 'defutf8 on'
#
#### main screen=... screen_setup
screen_setup=false
screen_setup() {
  if ! $screen_setup
  then
    ! { screen -ls | fgrep -q "$screen" ;} ||
    err 'screen_setup: Screen collision!'
    screen_S -dm -ln sleep 2 || err 'screen_setup: Failed to init a screen.'
    screen_S -X eval 'screen 1 sleep 1' 'select 0' kill "$@"
    screen_setup=true
  fi
}

# Launch command in initialized screen.
#### main screen=... screen_run
screen_run() {
  screen_setup
  screen_S -X screen 0 "$@"
  screen_S -X eval 'select 1' kill
  msg "New screen is:"
  out "$screen"
}


# Use curl to retrieve an archive, unpack it based on the type passed in, then
# execute other commands.
curl_archive() {
  curl --connection-timeout 100 -L "$1" |
  case "$2" in
    tar) tar -x ;;
    tgz) tar -xz ;;
    tbz) tar -jz ;;
    *)   err 'curl_archive: Unrecognized archive type token.' ;;
  esac
  shift ; shift
  "$@"
}


#### main syslog_tag=... logger_
logger_() {
  exec 4>&2 # Save the function's STDERR to &4.
{ exec 3>&1 # Save the grouping's STDERR to &3.
  "$@" 2>&1 1>&3 | # Write out to &3 and capture err in the pipe.
  logger -t "$syslog_tag" -i -p user.err -s 2>&4 1>&4 # Log err and echo.
}|logger -t "$syslog_tag" -i -p user.info -s 2>&1 1>&1 # &3 is in the pipe.
}


# Portably determine a canonical path for the first argument. Intended to
# emulate `readlink --canonical' on systems that have a readlink which
# supports it.
canonical_path() {
  ( cd "`dirname "$1"`"
    d="`pwd -P`"
    out "$d"/"`basename "$1"`"
  )
# LOLziness -- the canonical path of '.' is always '<something>/.'
}


# Create the target directory and move to it.
cd_p() {
  mkdir -p "$1"
  cd "$1"
  shift
  "$@"
}

# Return to the start directory.
## main pwd=... popd_
popd_() {
  cd "$pwd"
  "$@"
}

# Set a trap to remove the argument directory.
trap_tmp=
trap_on() {
  [ ! "${trap_tmp:-}" ] ||
  err 'trap_on: Var trap_tmp already in use! Was trap_on called twice???!!?!'
  trap_tmp="$1" ; shift
  trap 'case $?/$rm0/$rm1 in
          0/true/*)      rm -rf "$trap_tmp" ;;
          [1-9]*/*/true) rm -rf "$trap_tmp" ;;
        esac' EXIT
  trap 'exit 2' HUP INT QUIT BUS SEGV PIPE TERM
  "$@" # A subshell is necessary to protect the trap but we do not subshell
       # here because user code is always called behind exec.
}

# Disable the directory removal trap.
trap_off() {
  trap - EXIT HUP INT QUIT BUS SEGV PIPE TERM
}

# Create staging area and set a trap to ensure its removal.
## main dir=... tmp
tmp() {
  mkdir -p "`dirname "$dir"`"
  mkdir "$dir" # Fail if dir exists.
  cd "$dir"
  dir="`pwd -P`" # Update staging directory with absolute path.
  trap_tmp "$@"
}


err() {
  msg "$@"
  exit 2
}

msg() {
  printf '%s\n' "$*" 1>&2
}

out() {
  printf '%s\n' "$*"
}

main "$@"

