#!/bin/sh

# Note that shell variables are implicitly global. Thus, we require that all
# variables used in a function must be set in that function. Idempotent
# generators, like `tag', allow variables to be shared.

screen_S() {
  screen -S "`tag`" "$@"
}

# Initialize screen with settings. Settings are fed to screen's eval function,
# so each argument should be a string containg a whole setting, for example:
#
#   screen_setup 'zombie ko' 'defutf8 on'
#
screen_setup() {
  if [ ! -n "${screen_setup:-}" ]
  then
    tag="`tag`"
    ! { screen -ls | fgrep -q "$tag" ;} ||
      { err 'ERR: screen collision!' ; return 2 ;}
    ( cd / ; screen_S -dm -ln sleep 2 ) # Ensure PWD for screen is /.
    screen_setup=true
    screen_S      -X eval 'screen 1 sleep 1' 'select 0' kill "$@"
  fi
}

# Launch command in initialized screen, after calling back in to this library
# to reset the working directory (since the screen is running in /).
screen_() {
  this_script="`canonical_path "$0"`"
  screen_setup
  screen_S      -X screen 0 "$this_script" cd_ "`pwd -P`" "$@"
  screen_S      -X eval 'select 1' kill
  err "New screen is:"
  out "`tag`"
}


# Use curl to retrieve an archive, unpack it based on the type passed in, then
# execute other commands.
curl_archive() {
  curl --connection-timeout 100 -L "$1" |
  case "$2" in
    tar) tar -x ;;
    tgz) tar -xz ;;
    tbz) tar -jz ;;
    *)   err 'Unrecognized archive type token.' ;;
  esac
  shift ; shift
  "$@"
}


logger_() {
  syslog_tag="`tag`"
  exec 4>&2 # Save the function's STDERR to &4.
{ exec 3>&1 # Save the grouping's STDERR to &3.
  "$@" 2>&1 1>&3 | # Write out to &3 and capture err in the pipe.
  logger -t "$syslog_tag" -i -p user.err -s 2>&4 1>&4 # Log err and echo.
}|logger -t "$syslog_tag" -i -p user.info -s 2>&1 1>&1 # &3 is in the pipe.
}


# Portably determine a canonical path for the first argument. Intended to
# emulate `readlink --canonical' on systems that have a readlink which
# supports it.
canonical_path() {
  ( cd "`dirname "$1"`"
    d="`pwd -P`"
    out "$d"/"`basename "$1"`"
  )
# LOLziness -- the canonical path of '.' is always '<something>/.'
}


# Generates a tag for this process from the label and some random bytes.
# Subcommands that need a unique resource -- for example, a screen label --
# are very likely to get something unique this way; but they should always
# check it and fail if (by chance) another process has already taken it.
tag() {
  if [ ! -n "${tag:-}" ]
  then
    : ${label:=arx}
    tag="$label".`hexdump -n8 -e '"%08x-%08x"' < /dev/urandom`
  fi
  out "$tag"
}


# Have to wrap cd so we can change the directory within the context of
# external calls to the script. For example,
#
#  ./lib cd_ <dir> files_oe
#
cd_() {
  cd "$1"
  shift
  "$@"
}

trap_d() {
  
}


err() {
  echo "$@" 1>&2
}

out() {
  echo "$@"
}

"$@"

