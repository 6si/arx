#!/bin/sh


main() {
  set -eu
  vars defaults "$@"
}

# Sets defualts for unset vars and calls "$@".
defaults() {
  : ${rm0:=true}
  : ${rm1:=true}
  : ${flat_token:=true}
  : ${prefix:=arx}
  : ${token:=`time_and_pid "$flat_token"`}
  : ${tag:=${prefix:+${prefix}_}$token}
  : ${screen:=`tag`}
  "$@"
}

# Use recursion to process arguments for name=value pairs and set local shell
# variables in accord with them. When we're done with name=value pairs, call
# $1 with the remaining arguments.
vars() {
  command="$1" ; shift
  case "${1:-}" in
    command=*) err 'vars: It is an error to set command=...' ;;
    *=*)       typeset "$1" ; shift ; vars "$command" "$@" ;;
    *)         "$command" "$@"
  esac
}

# Generates an ID that is very likely unique on this system -- date to seconds
# and PID -- and optionally strips characters that make it easier to read but
# harder to use in URLs, in git branches, with Hadoop, in some build systems,
# in the PATH and probably many other things.
time_and_pid() {
  date -u +%FT%TZ#$$ | { ! $1 && cat || { tr -d :- | tr '#' _ ;} ;}
}


screen_S() {
  screen -S "$screen" "$@"
}

# Initialize screen with settings. Settings are fed to screen's eval function,
# so each argument should be a string containg a whole setting, for example:
#
#   screen_setup 'zombie ko' 'defutf8 on'
#
screen_setup=false
screen_setup() {
  if ! $screen_setup
  then
    ! { screen -ls | fgrep -q "$screen" ;} ||
    err 'screen_setup: screen collision!'
    ( cd / ; screen_S -dm -ln sleep 2 ) # Ensure CWD for screen is /.
    screen_setup=true
    screen_S -X eval 'screen 1 sleep 1' 'select 0' kill "$@"
  fi
}

# Launch command in initialized screen, after calling back in to this library
# to reset the working directory (since the screen is running in /).
screen_() {
  this_script="`canonical_path "$0"`"
  screen_setup
  screen_S -X screen 0 "$this_script" cd_ "`pwd -P`" "$@"
  screen_S -X eval 'select 1' kill
  msg "New screen is:"
  out "$screen"
}


# Use curl to retrieve an archive, unpack it based on the type passed in, then
# execute other commands.
curl_archive() {
  curl --connection-timeout 100 -L "$1" |
  case "$2" in
    tar) tar -x ;;
    tgz) tar -xz ;;
    tbz) tar -jz ;;
    *)   err 'Unrecognized archive type token.' ;;
  esac
  shift ; shift
  "$@"
}


logger_() {
  syslog_tag="`tag`"
  exec 4>&2 # Save the function's STDERR to &4.
{ exec 3>&1 # Save the grouping's STDERR to &3.
  "$@" 2>&1 1>&3 | # Write out to &3 and capture err in the pipe.
  logger -t "$syslog_tag" -i -p user.err -s 2>&4 1>&4 # Log err and echo.
}|logger -t "$syslog_tag" -i -p user.info -s 2>&1 1>&1 # &3 is in the pipe.
}


# Portably determine a canonical path for the first argument. Intended to
# emulate `readlink --canonical' on systems that have a readlink which
# supports it.
canonical_path() {
  ( cd "`dirname "$1"`"
    d="`pwd -P`"
    out "$d"/"`basename "$1"`"
  )
# LOLziness -- the canonical path of '.' is always '<something>/.'
}


# Generates a tag for this process from the label and some random bytes.
# Subcommands that need a unique resource -- for example, a screen label --
# are very likely to get something unique this way; but they should always
# check it and fail if (by chance) another process has already taken it.
tag() {
  if [ ! -n "${tag:-}" ]
  then
    : ${label:=arx}
    tag="$label".`hexdump -n8 -e '"%08x-%08x"' < /dev/urandom`
  fi
  out "$tag"
}


# Have to wrap cd so we can change the directory within the context of
# external calls to the script. For example,
#
#  ./lib cd_ <dir> files_oe
#
cd_() {
  cd "$1"
  shift
  "$@"
}

# Set a trap to remove the directory given as the first argument.
trap_d=
trap_d() {
  [ ! "${trap_d:-}" ] ||
  err 'trap_d: var trap_d already in use! trap_d called twice????!!!?!?'
  trap_d="$1"
  trap 'case $?/$rm0/$rm1 in
          0/true/*)      rm -rf "$trap_d" ;;
          [1-9]*/*/true) rm -rf "$trap_d" ;;
        esac' EXIT
  trap 'exit 2' HUP INT QUIT BUS SEGV PIPE TERM
}

err() {
  msg "$@"
  exit 2
}

msg() {
  printf '%s\n' "$*" 1>&2
}

out() {
  printf '%s\n' "$*"
}

main "$@"

