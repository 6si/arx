#!/bin/sh

# Note that shell variables are implicitly global. Thus, we require that all
# variables used in a function must be set in that function. Idempotent
# generators, like `tag', allow variables to be shared.

screen_S() {
  tag="`tag`"
  screen -S "$tag" "$@"
}

# Initialize screen with settings. Settings are fed to screen's eval function,
# so each argument should be a string containg a whole setting, for example:
#
#   screen_setup 'zombie ko' 'defutf8 on'
#
screen_setup() {
  if [ ! -n "${screen_setup:-}" ]
  then
    tag="`tag`"
    ! { screen -ls | fgrep -q "$tag" ;} ||
      { echo 'ERR: screen collision!' 1>&2 ; return 2 ;}
    ( cd / ; screen_S -dm -ln sleep 2 ) # Ensure PWD for screen is /.
    screen_setup=true
    screen_S      -X eval 'screen 1 sleep 1' 'select 0' kill "$@"
  fi
}

# Launch command in initialized screen.
screend() {
  tag="`tag`"
  screen_setup
  screen_S      -X screen 0 "$@"
  screen_S      -X eval 'select 1' kill
  echo "$tag"
}


envx() {
  [ ! -f ./env ] || . ./env
  "$@"
}


tmpx_create() {
  tmp=/tmp      # Templated.
  tag="`tag`"
  dir="$tmp"/"$tag"
  [ ! -e "$dir" ] || { echo 'ERR: tmp dir collision!' 1>&2 ; return 2 ;}
  mkdir -p "$dir"
  cd "$dir"
}

tmpx_trap() {
  cd "$1" ; shift
  rm0=true      # Templated.
  rm1=true      # Templated.
  rm_=true
  pwd="`pwd -P`"
  trap 'case $?/$rm0/$rm1 in
          0/true/*)      rm -rf "$pwd" ;;
          [1-9]*/*/true) rm -rf "$pwd" ;;
        esac' EXIT
  trap 'exit 2' HUP INT QUIT BUS SEGV PIPE TERM
  ( "$@" ) # We use a subshell to protect the trap and its environment.
}


# Log to files o and e in the present directory.
files_oe() {
  "$@" 2>e 1>o
}

tee_oe() {
  general_redirect o e tee "$@"
}

syslog_oe() {
  general_redirect user.err user.info logger_shim "$@"
}

logger_shim() {
  tag="`tag`"
  logger -t "$tag" -i -p "$1"
}

# This redirect pattern is used for tee and logger.
general_redirect() {
  o="$1" ; e="$2" ; c="$3"
  shift  ; shift  ; shift
{ # Here, &1 refers to the grouping's STDOUT. We save it in &3.
  exec      3>&1
  # In this line, &1 and &2 refer to the file descriptors of the command, not
  # of the grouping. We cause the STDERR reference to point to the new output
  # stream for this command, which is a pipe to the error logger, while we
  # cause the STDOUT reference to point to the output stream of the grouping
  # as a whole, which is a piped to the output logger.
  "$@"      2>&1 1>&3 |
  # Cause whatever output is produced by the error logger to go back on
  # STDERR. Tee will copy its input to STDOUT and logger can be made to copy
  # its input to STDERR; we handle both cases.
  "$c" "$e" 2>&2 1>&2 ;} |
  # Cause whatever output is produced by the output logger to go back on
  # STDOUT, similar to the case for the error logger.
  "$c" "$o" 2>&1 1>&1
}


# Have to wrap cd so we can change the directory within the context of
# external calls to the script. For example,
#
#  ./lib cdx <dir> files_oe
#
cdx() {
  target_dir="$1"
  shift
  cd "$target_dir"
  "$@"
}


# Generates a tag for this process from the label, the date up to seconds and
# the PID. The tag is used to label screen sessions, temporary directories and
# so forth. It is very unlikely the tag will collide with any other created
# tag; but all commands that create resources, like screen_setup, should check
# for a collision and fail if one is found.
tag() {
  if [ ! -n "${tag:-}" ]
  then
    label=arx     # Templated.
    tag="$label".`date -u +%FT%TZ`.$$
  fi
  echo "$tag"
}


case "${1:-}" in
  tmpx_create|tmpx_trap|envx|screend|cdx) set -eu
                                              "$@" ;;
  tmpx) set -eu
        tmpx_create
        tmpx_trap "$@" ;;
  ?*)   echo 'Subcommand not found.' 1>&2 ; exit 2 ;;
esac


# Must mkdir and unpack tarballs before running screen.
#   tmpx_create
# Tar unpacking goes here.
# However, must setup screen before setting trap. We actually have to call in
# to lib again, in a new shell.
#   screend ./lib tmpx_trap "$dir" envx exec "$@"


# Just run command in a tmp directory cleaned up with a trap.
#   tmpx_create
#   tmpx_trap "$@"

