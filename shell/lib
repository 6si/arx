#!/bin/sh


screen_S() {
  tag
  screen -S "$tag" "$@"
}

# Initialize screen with settings.
screen_setup=false
screen_setup() { $screen_setup || {
  ( cd / ; screen_S -dm -ln sleep 2 ) # Ensure PWD for screen is /.
  screen_setup=true
  screen_S      -X eval 'screen 1 sleep 1' 'select 0' kill "$@"
} }

# Launch command in initialized screen.
screend() {
  screen_setup
  screen_S      -X screen 0 "$@"
  screen_S      -X eval 'select 1' kill
  echo "$tag"
}


envx() {
  [ ! -f ./env ] || . ./env
  exec "$@"
}


tmpx_create() {
  tmp=/tmp      # Templated.
  tag
  dir="$tmp"/"$tag"
  [ ! -e "$dir" ] || { echo 'ERR: tmp dir collision!' 1>&2 ; return 2 ;}
  mkdir -p "$dir"
  cd "$dir"
}

tmpx_trap_dot() {
  rm0=true      # Templated.
  rm1=true      # Templated.
  rm_=true
  dir="`pwd -P`"
  trap 'case $?/$rm0/$rm1 in
          0/true/*)      rm -rf "$dir" ;;
          [1-9]*/*/true) rm -rf "$dir" ;;
        esac' EXIT
  trap 'exit 2' HUP INT QUIT BUS SEGV PIPE TERM
  ( "$@" ) # We use a subshell to protect the trap and its environment.
}


# Log to files o and e in the present directory.
files_oe() {
  "$@" 2>e 1>o
}

logger_shim() {
  logger -t "$tag" -i -p "$1"
}

# This redirect pattern is used for tee and logger.
general_redirect() {
  o="$1" ; e="$2" ; c="$3"
  shift  ; shift  ; shift
{ # Here, &1 refers to the grouping's STDOUT. We save it in &3.
  exec      3>&1
  # In this line, &1 and &2 refer to the file descriptors of the command, not
  # of the grouping. We cause the STDERR reference to point to the new output
  # stream for this command, which is a pipe to the error logger, while we
  # cause the STDOUT reference to point to the output stream of the grouping
  # as a whole, which is a piped to the output logger.
  "$@"      2>&1 1>&3 |
  # Cause whatever output is produced by the error logger to go back on
  # STDERR. Tee will copy its input to STDOUT and logger can be made to copy
  # its input to STDERR; we handle both cases.
  "$c" "$e" 2>&2 1>&2 ;} |
  # Cause whatever output is produced by the output logger to go back on
  # STDOUT, similar to the case for the error logger.
  "$c" "$o" 2>&1 1>&1
}

tee_oe() {
  general_redirect o e tee "$@"
}

syslog_oe() {
  general_redirect user.err user.info logger_shim "$@"
}


# Haha, cd and run command.
cdx() {
  target_dir="$1"
  shift
  cd "$target_dir"
  "$@"
}


tag() { [ -n "${tag:-}" ] || {
  label=arx     # Templated.
  tag="$label".`date -u +%FT%TZ`.`pid_and_random_hex`
} }

pid_and_random_hex() {
  { echo $$ ; head -c 8 /dev/urandom ;} | head -c 8 | hexdump -e '"%08x"'
}

case "${1:-}" in
  tmpx_create|tmpx_trap_dot|envx|screend|cdx)
    set -e -u
    "$@" ;;
  *)
    echo 'Subcommand not found.' 1>&2
    exit 2 ;;
esac

exit



# Must mkdir and unpack tarballs before running screen.
tmpx_create
# Tar unpacking goes here.
# However, must setup screen before setting trap. We actually have to call in
# to lib again, in a new shell.
screend ./lib cdx "$dir" tmpx_trap_dot envx "$@"


# Just run command in a tmp directory cleaned up with a trap.
tmpx_create
tmpx_trap_dot "$@"

